<!doctype html><html lang=zh-cn data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Distributed System: Primary Backup Replication - Junyi&rsquo;s Lab</title>
<meta name=description content="开胃菜来了！
你有一个硬盘，存了很多重要资料，你担心这个硬盘某天坏了，怎么办？
当然是多买点硬盘，把数据备份在不同的硬盘上。"><link rel=icon type=image/x-icon href=https://www.junyi.dev/favicon.ico><link rel=apple-touch-icon-precomposed href=https://www.junyi.dev/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=/css/style.min.1a8367ff0bfba6eb7139961471f4e25c9a79359a0ab5c8da60b448cb9658a455.css integrity="sha256-GoNn/wv7putxOZYUcfTiXJp5NZoKtcjaYLRIy5ZYpFU="><link rel=stylesheet href=/css/style.min.c4c04b3ef88e3d619ad4c7ee5e03048422bc55c4fefdc1f07657c1133670aa22.css integrity="sha256-xMBLPviOPWGa1MfuXgMEhCK8VcT+/cHwdlfBEzZwqiI="><link rel=stylesheet href=/css/style.min.21c5d8fe0a79d623b0adc1ce4bd4f6dd2c05cd939c9aaaa966ba7186b1464f4d.css integrity="sha256-IcXY/gp51iOwrcHOS9T23SwFzZOcmqqpZrpxhrFGT00="><script src=/js/script.min.08f04d96386c73c9bf4d160333f8f448c05a6e01c06770542ee0e013954ce930.js type=text/javascript integrity="sha256-CPBNljhsc8m/TRYDM/j0SMBabgHAZ3BULuDgE5VM6TA="></script><script async defer data-website-id=dd99a470-c29d-4882-8c6a-89f1cec9045c data-cache=false data-do-not-track=false src=https://analytics.eu.umami.is/script.js></script></head><body><a class=skip-main href=#main>跳至内容</a><div class=container><header class=common-header><div class=header-top><div class=header-top-left><h1 class="site-title noselect"><a href=/>Junyi's Lab</a></h1><div class=theme-switcher><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-sun-high"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14.828 14.828A4 4 0 109.172 9.172a4 4 0 005.656 5.656z"/><path d="M6.343 17.657l-1.414 1.414"/><path d="M6.343 6.343 4.929 4.929"/><path d="M17.657 6.343l1.414-1.414"/><path d="M17.657 17.657l1.414 1.414"/><path d="M4 12H2"/><path d="M12 4V2"/><path d="M20 12h2"/><path d="M12 20v2"/></svg></span></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");function switchTheme(){currentTheme=currentTheme==="dark"?"light":"dark",localStorage&&localStorage.setItem(STORAGE_KEY,currentTheme),document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))}const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme==="auto"?(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)):document.documentElement.setAttribute("data-theme",currentTheme),switchButton&&switchButton.addEventListener("click",switchTheme,!1),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}function changeGiscusTheme(e){function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script><ul class="social-icons noselect"><li><a href=https://github.com/Junyi-99 title=Github rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-github"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></span></a></li><li><a href=https://www.linkedin.com/in/junyi-hou-00b668248/ title=Linkedin rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></span></a></li><li><a href=/index.xml title=RSS rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></span></a></li></ul></div><div class=header-top-right></div></div><nav class=noselect><a href=https://www.junyi.dev/ title>HOME</a>
<a href=https://www.junyi.dev/gallery/ title>GALLERY</a>
<a href=https://www.junyi.dev/tags/ title>TAGS</a>
<a href=https://www.junyi.dev/posts/ title>ARCHIVE</a>
<a href=https://www.junyi.dev/about/ title>ABOUT</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">Distributed System: Primary Backup Replication</h1></header><div class="post-info noselect"><div class="post-date dt-published"><time datetime=2023-09-12>September 12, 2023</time></div><a class="post-hidden-url u-url" href=/posts/paxos-review-3/>/posts/paxos-review-3/</a>
<a href=https://www.junyi.dev/ class="p-name p-author post-hidden-author h-card" rel=me>Junyi Hou</a><div class=post-taxonomies><ul class=post-tags><li><a href>#技术文章</a></li><li><a href=/tags/distributed-system/>#Distributed System</a></li></ul></div></div></div><details class="toc noselect"><summary>Table of Contents</summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前提假设>前提假设</a></li><li><a href=#最简单的-primary--backup>最简单的 primary & backup</a></li><li><a href=#什么是-view-server-里的-view>什么是 view-server 里的 view</a></li><li><a href=#总结一下所有的规则>总结一下所有的规则</a></li><li><a href=#脑裂-split-brain>脑裂 (Split-brain)</a></li><li><a href=#系统卡住>系统卡住</a></li><li><a href=#重复写入>重复写入</a></li><li><a href=#为什么-primary-backup-比较难>为什么 Primary Backup 比较难</a></li><li><a href=#总结一下-view-server-的缺点>总结一下 view-server 的缺点</a></li><li><a href=#ruby状态机复制rtstate-machine-replicationrtruby><ruby>状态机复制<rt>State Machine Replication</rt></ruby></a></li></ul></nav></div></details><script>var toc=document.querySelector(".toc");toc&&toc.addEventListener("click",function(){event.target.tagName!=="A"&&(event.preventDefault(),this.open?(this.open=!1,this.classList.remove("expanded")):(this.open=!0,this.classList.add("expanded")))})</script><div class="content e-content"><p>开胃菜来了！</p><p>你有一个硬盘，存了很多重要资料，你担心这个硬盘某天坏了，怎么办？</p><p>当然是多买点硬盘，把数据备份在不同的硬盘上。</p><p>保证可靠，就是通过多个一致的数据副本来实现的。</p><hr><h2 id=前提假设><div><a href=#%e5%89%8d%e6%8f%90%e5%81%87%e8%ae%be>#
</a>前提假设</div></h2><p>我们假设所有的操作都是<ruby>确定<rt>deterministic</rt></ruby>的</p><h2 id=最简单的-primary--backup><div><a href=#%e6%9c%80%e7%ae%80%e5%8d%95%e7%9a%84-primary--backup>#
</a>最简单的 primary & backup</div></h2><ol><li>client<strong>s</strong> 发送 operation (Put, Get, Append) 到 primary-server</li><li>primary-server 决定 operation 的执行顺序</li><li>primary-server 把 operation 的执行顺序发送给 backup-server</li><li>backup-server 按照 primary-server 发送的顺序执行 operation（hot-standby）<ul><li>或者 backup-server 按照 primary-server 发送的顺序记录 operation 但不执行（cold-standby）</li></ul></li><li>等 backup-server 成功结束，primary-server 给 client 发回复</li></ol><p><strong>问题是，怎么决定谁来当 primary-server？</strong></p><p><strong>怎么决定谁来当 backup-server？</strong></p><p><strong>client 怎么知道谁是 primary-server？</strong></p><p><strong>答案：</strong> <span class=spoiler>引入一台 view-server，让这个 view-server 来做决定，并且 client 去问 view-server 谁是 primary-server。为什么叫它 view-server？因为这涉及到一个重要概念「view」，后面会讲到，别着急！</span></p><p>知道了答案，我们可以这样设计整个系统：</p><ul><li><p>我们让每台服务器发送心跳给 view-server，告诉 view-server 自己还活着。</p><p>问：有没有可能自己活着但是 view-server 认为自己死了？<span class=spoiler> 有可能因为网络问题，心跳没发出去，view-server 认为节点挂了，但其实节点还活着</span></p></li><li><p>我们 promote idle-server 成为 backup-server，但不越级 promote 成为 primary-server</p><p>问：除非有种情况？<span class=spoiler>系统刚启动时（全都是 idle-server、需要一个 primary 的时候）</span></p></li><li><p>只有 backup-server 会被 promote 成 primary-server</p></li></ul><figure><img src=view-service.png alt="View Service" width=500><figcaption>Fig.1 - One View Server and Two Nodes</figcaption></figure><h2 id=什么是-view-server-里的-view><div><a href=#%e4%bb%80%e4%b9%88%e6%98%af-view-server-%e9%87%8c%e7%9a%84-view>#
</a>什么是 view-server 里的 view</div></h2><p>一个 view 是一个 primary-server 和一个 backup-server 的集合，描述了当前状态<strong>谁是 primary 谁是 backup</strong>。</p><p>注意，一个 view 里，只有一个 primary 和一个 backup，其它的 server 标记为 idle。（想想看为什么这样设计？）</p><p>view 由 view-server 进行管理，其他节点可以获取到当前系统的 view。</p><figure><img src=view.png alt=view-service width=400><figcaption>Fig.2 - Example of three different views, denotes three different states of the system</figcaption></figure><p><strong>看了上面的描述，感觉自己又行了，于是我设计出了下面的流程</strong></p><blockquote><p>系统刚开始，挑一个 primary-server，然后挑一个 backup-server，其它的都是 idle-server，然后开始工作。</p><p>primary 立马让 backup 成为新的 primary，从 idle 里面挑一个成为 backup，然后让这个新的 primary 把状态都发送给 backup</p></blockquote><p><strong>很简单嘛！这能有什么问题？</strong></p><p>话音刚落，问题就来了。</p><p>请看下面这个情况：</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#5af78e>`View 1, primary=A, backup=B;`</span> 这时候 A 挂了，B 成为 primary，从 idle 里面挑一个 C 成为 backup，然后 B 发送状态给 C。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#5af78e>`View 2, primary=B, backup=C;`</span> B 发状态的时候挂了，C 成为 primary，idle 里面没机器了
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#5af78e>`View 3, primary=C, backup=_;`</span> C：😅？（此时 C 根本不知道系统的状态是什么）
</span></span></code></pre></div><p>所以我们刚刚对整个系统的描述，是有缺陷的。</p><p>怎么改呢，我们让 view-server 必须等待 primary-server <ruby>确认<rt>ACK</rt></ruby> 当前的 view。</p><p>就算 primary-server 挂了，view-server 也要等 ACK。</p><p>（直觉告诉我们，这种等待 ACK 的行为可能导致系统卡住）</p><h2 id=总结一下所有的规则><div><a href=#%e6%80%bb%e7%bb%93%e4%b8%80%e4%b8%8b%e6%89%80%e6%9c%89%e7%9a%84%e8%a7%84%e5%88%99>#
</a>总结一下所有的规则</div></h2><ol><li><p>在 view i+1 的 primary 必须是 view i 的 backup</p><p>如果没有这个规则会怎样？<span class=spoiler><strong>Split brain:</strong> primary A, backup B, but can&rsquo;t reach view-server. C,D are promoted to primary and backup, C doesn&rsquo;t know previous state.</span></p></li><li><p>primary 必须等 backup 执行完，才可以回复 client</p><p>如果没有这个规则会怎样？<span class=spoiler><strong>Missing write:</strong> client writes to A，A crashes before writing to B, clients read from B</span></p><p>一定要转发 read() 给 backup 吗？（这是一个常见的优化操作）<span class=spoiler>必须转发。不然可能出现 <strong>Stale read</strong>: at <em>view 1</em>, A,B are primary and backup, but A cannot reach view-server. now <em>view 2</em>, B,C are primary backup. client 1 writes to B, client 2 reads from A. A returns outdated data（不过 stale read 依然符合 sequential consistency）</span></p></li><li><p>如果 view 是正确的，backup 必须接受<ruby>转发的请求<rt>Forwarded Request</rt></ruby>，并且执行</p><p>如果没有这个规则会怎样？<span class=spoiler><strong>Partially Split Brain</strong></span></p></li><li><p>non-primary 节点<strong>必须拒绝</strong> client 的请求</p><p>如果没有这个规则会怎样？<span class=spoiler><strong>Inconsistencies:</strong> client&rsquo;s view may outdated, send request to old primary server.</span></p></li><li><p>state-transfer 的时候不能有操作。（Atomic State Transfer）</p><p>如果没有这个规则会怎样？<span class=spoiler></span></p></li></ol><h2 id=脑裂-split-brain><div><a href=#%e8%84%91%e8%a3%82-split-brain>#
</a>脑裂 (Split-brain)</div></h2><p>这个词有点吓人。。。其实是在说：<strong>在网络故障时，两个及以上的节点都认为自己是 Leader (primary-server)。</strong></p><blockquote><p>View 1, primary=A, backup=B; 这时候 A 网络出故障无法连接到 view-server，B 成为新的 primary。
View 2, primary=B, backup=_; B 是 新的 primary，但 A 也认为自己是 primary</p></blockquote><p>在我们之前的规定里，只有 primary-server 会回复 client，但是脑裂的时候，两个节点都会回复 client，这就可能导致 client 收到的数据不一致。
（破坏了 Linearzability）</p><h2 id=系统卡住><div><a href=#%e7%b3%bb%e7%bb%9f%e5%8d%a1%e4%bd%8f>#
</a>系统卡住</div></h2><p>有哪些可能导致系统卡住（处理不了 client 的请求）的情况？</p><ol><li>view-server 挂了</li><li>整个网络挂了</li><li>client 只能练到 view-server，不能连接到 primary-server</li><li>backup server 没有了（因为 primary 转移状态给 backup，转移完了回复 view-server 一个 ACK）</li><li>状态转移之前 primary 挂了</li></ol><h2 id=重复写入><div><a href=#%e9%87%8d%e5%a4%8d%e5%86%99%e5%85%a5>#
</a>重复写入</div></h2><h2 id=为什么-primary-backup-比较难><div><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88-primary-backup-%e6%af%94%e8%be%83%e9%9a%be>#
</a>为什么 Primary Backup 比较难</div></h2><ul><li>primary 可能挂掉</li><li>backup 可能挂掉</li><li>通讯可能 临时/永久 挂掉</li><li>参与者的决策可能存在延迟：<ul><li>view server 不知道 primary 挂了</li><li>primary 挂了吗？挂了之后恢复，还需要回复 client 吗？</li><li>backup 挂了吗？state transfer 结束了吗？</li><li>client 不知道 view 有没有切换</li></ul></li></ul><h2 id=总结一下-view-server-的缺点><div><a href=#%e6%80%bb%e7%bb%93%e4%b8%80%e4%b8%8b-view-server-%e7%9a%84%e7%bc%ba%e7%82%b9>#
</a>总结一下 view-server 的缺点</div></h2><ol><li>view-server 自己存在单点故障问题</li><li>view-server 必须等待 primary 的 ack，即使 primary 可能挂了也要等</li></ol><h2 id=ruby状态机复制rtstate-machine-replicationrtruby><div><a href=#ruby%e7%8a%b6%e6%80%81%e6%9c%ba%e5%a4%8d%e5%88%b6rtstate-machine-replicationrtruby>#
</a><ruby>状态机复制<rt>State Machine Replication</rt></ruby></div></h2><blockquote><p><strong>状态机有一个特性：</strong> 任何初始状态一样的状态机，如果执行的命令序列一样，则最终达到的状态也一样。</p><p>如果将此特性应用在多参与者进行协商共识上，可以理解为系统中存在多个具有完全相同的状态机（参与者），这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致。</p></blockquote><p>根据状态机的特性，要让多台机器的最终状态一致，只要确保它们的初始状态是一致的，并且接收到的操作指令序列也是一致的即可，无论这个操作指令是新增、修改、删除抑或是其他任何可能的程序行为，都可以理解为要将一连串的操作日志正确地广播给各个分布式节点。</p><p>我们并不要求所有节点的每一条指令都是同时开始、同步完成的，只要求在此期间的内部状态不能被外部观察到，且当操作指令序列执行完毕时，所有节点的最终的状态是一致的，这种模型就被称为状态机复制（State Machine Replication）。</p><style>.spoiler{color:#000;background-color:#000;transition:color .2s;border-radius:5px;padding-right:5px;padding-left:5px}.spoiler:hover{visibility:visible;color:#fff}</style></div></article><h3 class="read-next-title noselect">继续阅读</h3><ul class="read-next-posts noselect"><li><a href=/posts/paxos-review-2/>Distributed System: Consistency</a></li><li><a href=/posts/paxos-review-1/>Distributed System: Ordering of events</a></li><li><a href=/posts/ra-experience/>当 RA 的我学到了什么：如何优化实验流程</a></li></ul><script>function detectCurrentScheme2(){const e="auto";return localStorage!==null&&localStorage.getItem("user-color-scheme")?localStorage.getItem("user-color-scheme"):e==="dark"||e==="light"?e:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}let giscusTheme=detectCurrentScheme2(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Junyi-99/Junyi-99.github.io","data-repo-id":"MDEwOlJlcG9zaXRvcnkzNDI4ODI3NzY=","data-category":"Announcements","data-category-id":"DIC_kwDOFG_52M4CZZZF","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",lazyload:"false",async:!0},main=document.querySelector("main"),giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t)),main.appendChild(giscusScript)</script></main><footer class="common-footer noselect"><ul class=language-select><li>Simplified Chinese</li><li><a href=/en/>English</a></li></ul><div class=common-footer-bottom><div style=display:flex;align-items:center;gap:8px>© Junyi Hou, 2024
<a aria-label="Check statistics data" style=display:flex;align-items:center;border-bottom:none;cursor:pointer;color:var(--pagination-link-color) href=https://eu.umami.is/share/2uUOpgCbx28B16Ro/www.junyi.dev><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-report-analytics"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5H7A2 2 0 005 7v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><path d="M9 3m0 2a2 2 0 012-2h2a2 2 0 012 2v0a2 2 0 01-2 2h-2A2 2 0 019 5z"/><path d="M9 17v-5"/><path d="M12 17v-1"/><path d="M15 17v-3"/></svg></a></div><div>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/Junyi-99/hugo-theme-anubis2>Anubis2</a>.<br></div></div><p class="h-card vcard"><a href=https://www.junyi.dev/ class="p-name u-url url fn" rel=me>Junyi Hou</a>
/
<a class="p-email u-email email" rel=me href=mailto:junyi.h@comp.nus.edu.sg>junyi.h@comp.nus.edu.sg</a></p></footer></div></body></html>