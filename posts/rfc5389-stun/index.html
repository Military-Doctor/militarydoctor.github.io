<!doctype html><html lang=zh-CN data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>RFC5389 - Session Traversal Utilities for NAT 翻译 - Junyi&rsquo;s Lab</title>
<meta name=description content="STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。
STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。"><link rel=icon type=image/x-icon href=https://www.junyi.dev/favicon.ico><link rel=apple-touch-icon-precomposed href=https://www.junyi.dev/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=https://www.junyi.dev/css/style.min.2415f8572cfbf625967d1fb9dd3f4942fe5918b2915be8ee05e427a77fb9efe9.css integrity="sha256-JBX4Vyz79iWWfR+53T9JQv5ZGLKRW+juBeQnp3+57+k="><script src=https://www.junyi.dev/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js type=text/javascript integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script><script async defer data-website-id=dd99a470-c29d-4882-8c6a-89f1cec9045c data-cache=false data-do-not-track=false src=https://analytics.eu.umami.is/script.js></script></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><div class="header-top noselect"><h1 class=site-title><a href=/>Junyi's Lab</a></h1><ul class=social-icons><li><a href=https://github.com/Junyi-99 title=Github rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></li></ul></div><nav class=noselect><a href=https://www.junyi.dev/ title>Home</a>
<a href=https://www.junyi.dev/tags/ title>Tags</a>
<a href=https://www.junyi.dev/posts/ title>Archive</a>
<a href=https://www.junyi.dev/about/ title>About</a></nav><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">RFC5389 - Session Traversal Utilities for NAT 翻译</h1></header></div><nav id=TableOfContents><ul><li><a href=#4-术语-terminology-4-术语-terminology4-术语-terminology><a href=#4-%E6%9C%AF%E8%AF%AD-Terminology title="4. 术语 Terminology"></a>4. 术语 Terminology</a></li><li><a href=#5-定义-definitions-5-定义-definitions5-定义-definitions><a href=#5-%E5%AE%9A%E4%B9%89-Definitions title="5. 定义 Definitions"></a>5. 定义 Definitions</a></li><li><a href=#6-stun-消息结构-stun-message-structure-6-stun-消息结构-stun-message-structure6-stun-消息结构-stun-message-structure><a href=#6-STUN-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84-STUN-Message-Structure title="6. STUN 消息结构 STUN Message Structure"></a>6. STUN 消息结构 STUN Message Structure</a></li></ul></nav><div class="content e-content"><p>STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。</p><p>STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透<strong>条件检测工具</strong>。</p><h1 id=说在前面>说在前面
<span><a href=#%e8%af%b4%e5%9c%a8%e5%89%8d%e9%9d%a2><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h1><p><strong>转载请注明作者及出处！</strong></p><p>翻译中遇到的问题：</p><ul><li><input disabled type=checkbox> 文章不能很好区分 indication 和 indication transaction</li><li><input disabled type=checkbox> 存在不理解的内容以该格式进行标记 <span style=color:red>?? 不理解的内容？？</span></li></ul><p>还未检查的项目：</p><ul><li><input disabled type=checkbox> 翻译的名词不会一个单词多个翻译。保证一致性</li><li><input disabled type=checkbox> 句子结束的句号是否完整</li><li><input disabled type=checkbox> 单词左右两边是否有空格</li><li><input disabled type=checkbox> 大小写、拼写问题</li><li><input disabled type=checkbox> 或、且，是否全都是左右两边加逗号</li></ul><p><strong>译者注：</strong></p><p>本翻译仅供参考，目的是让读者更好地理解 STUN 协议（<a href>RFC 5389</a>）。</p><p><strong>我个人</strong>对翻译的要求是逻辑严密准确，且文章<strong>核心内容</strong>与英文原版一致。</p><p>为了更方便读者理解，本翻译 <strong>不保证</strong> 部分措辞细节与英文原版一致。</p><p>为了保证文章的准确性，个别名词将不会进行翻译。</p><p>同样，为了保证文章的准确性，每句话的翻译都会附上英文原版供读者参考。</p><p>译者语文和英语的水平都不高，再次强调，本翻译仅供参考。</p><p>译者：Junyi</p><p>联系邮箱：hhh#u.nus.edu (自行替换成 at 符号)</p><h1 id=stun>STUN
<span><a href=#stun><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h1><p>STUN 全名叫 Session Traversal Utilities for NAT (STUN)</p><p>最新定义在 <a href=https://datatracker.ietf.org/doc/rfc5389/>RFC 5389</a></p><p>STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。</p><p>STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。</p><p>STUN 最初定义在 RFC 3489，有时我们也说这个最初版本为 “经典 STUN” （classic STUN）</p><p>在那时候其实已经是一个完整的 NAT 穿透问题的解决方案了，客户端可以去发现自己是否在 NAT 之后，确定其所在 NAT 的类型，发现其经过 NAT 转换后的 IP 地址和端口号，利用这个 IP 地址和端口号执行 SIP（Session Initiation Protocol）。</p><p><strong>听起来挺美好的哈，但是随着我们的应用部署，发现经典的 STUN 有时候根本不工作！</strong></p><ul><li><p>通过 STUN 获取到的 IP 地址和端口信息有时候可以让两个 peer 互通，有时候不行</p></li><li><p>在 peer 不互通时，经典 STUN 没有提供补救措施</p></li><li><p>在有些 NAT 内，经典 STUN 的算法是错误的</p></li><li><p>经典 STUN 存在安全漏洞（攻击者可以给 peer 提供错误的映射地址、拓扑、约束）。这个问题无法从根本解决，我们最新的协议也只能缓解这个问题。</p></li></ul><p>基于以上原因，RFC 3489 <strong>已经被废弃</strong>。</p><h1 id=3-操作概述-overview-of-operation>3. 操作概述 Overview of Operation
<span><a href=#3-%e6%93%8d%e4%bd%9c%e6%a6%82%e8%bf%b0-overview-of-operation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h1><blockquote><p>This section is descriptive only.</p></blockquote><p>本节仅作描述性用途。</p><blockquote><p>STUN is a client-server protocol.</p></blockquote><p>STUN 是一种 client-server 协议，换句话讲，运行 STUN 协议实现的主机既可以充当客户端也可以充当服务器。</p><blockquote><p>It supports two types of transactions.</p></blockquote><p>STUN 支持两种类型的事务。</p><blockquote><p>One is a <strong>request/response transaction</strong> in which a client sends a request to a server, and the server returns a response.</p></blockquote><p>其中一种是<strong>请求/响应型事务</strong>。就是说客户端发送一个 request 给服务器，服务器返回给客户端一个 response 。</p><blockquote><p>The second is an <strong>indication transaction</strong> in which either agent – client or server – sends an indication that generates no response.</p></blockquote><p>另一种是<strong>指示型事务</strong>。客户端或服务器只是??发送一个指示，并没有任何 response。??</p><blockquote><p>Both types of transactions include a <strong>transaction ID</strong>, which is a randomly selected 96-bit number.</p></blockquote><p>上述的两种事务类型，都包含一个随机选择的96位的事务ID。</p><blockquote><p>For <strong>request/response transactions</strong>, this transaction ID allows the client to associate the response with the request that generated it; for <strong>indications</strong>, the transaction ID serves as a debugging aid.</p></blockquote><p>对于<strong>请求/响应型事务</strong>，??事务ID允许客户端将其生成的请求事务与收到的响应事务相关联。??</p><p>对于<strong>指示型事务</strong>，事务ID充当调试工具的角色。</p><blockquote><p>All STUN messages start with a fixed header that includes a <strong>method</strong>, a <strong>class</strong>, and the <strong>transaction ID</strong>.</p></blockquote><p>所有的 STUN 消息都以一个固定的头部开始。这个头部包含<strong>方法</strong>、<strong>类</strong>、<strong>事务ID</strong>[^1]</p><ul><li><blockquote><p>The <strong>method</strong> indicates which of the various requests or indications this is; this specification defines just one method, Binding, but other methods are expected to be defined in other documents.</p></blockquote><p><strong>方法</strong>表示这是哪种请求，或，这是哪种<strong>指示</strong>。在当前您阅读的这个 RFC 规范里，我们只规定了一种方法：Binding。（其他的方法有望在其他文档中定义）</p></li><li><blockquote><p>The <strong>class</strong> indicates whether this is a request, a <strong>success response</strong>, an <strong>error response</strong>, or an <strong>indication</strong>.</p></blockquote><p>类表示这是一个请求、成功的响应、错误的响应还是一个指示。</p></li></ul><blockquote><p>Following the fixed header comes zero or more attributes, which are <strong>Type-Length-Value</strong> extensions that convey additional information for the specific message.</p></blockquote><p>紧跟在固定头部后面的是 0 个或多个 <strong>Type-Length-Value</strong> 扩展属性。不用细说，相信你也明白这个扩展属性的用途是为了传递附加信息。</p><hr><blockquote><p>This document defines a single method called Binding. The Binding method can be used either in request/response transactions or in indication transactions.</p></blockquote><p>这份文档只定义了 Binding 这个方法，这个方法既可以用在请求/响应型事务，又可以用在指示型事物。</p><blockquote><p>When used in request/response transactions, the Binding method can be used to determine the particular “binding” a NAT has allocated to a STUN client. When used in either request/ response <strong>or</strong> in indication transactions, the Binding method can also be used to keep these “bindings” alive.</p></blockquote><p>当在请求/响应型事务中使用 Binding 方法时，它可以用来确定一个 NAT 分配给 STUN 客户端的特定 “绑定”。</p><p>当在请求/响应型事务<strong>或</strong>指示型事物中使用 Binding 方法时，这个方法还可以用来维持这些特定 “绑定” 是活动的。</p><hr><blockquote><p>In the Binding request/response transaction, a Binding request is sent from a STUN client to a STUN server.</p></blockquote><p>在使用 Binding 方法的请求/响应型事务中，一条 Binding 请求 会从 STUN 客户端发往 STUN 服务器。</p><blockquote><p>When the Binding request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server (in Figure 1, there were two such NATs).</p></blockquote><p>一条 Binding 请求 到达 STUN 服务器的过程里，可能会穿越 1 个或多个 NAT 设备。（在 Figure 1 中穿越了两个 NAT 设备）</p><blockquote><p>As the Binding request message passes through a NAT, the NAT will modify the source transport address (that is, the source IP address and the source port) of the packet. As a result, the source transport address of the request received by the server will be the public IP address and port created <strong>by the NAT closest to the server</strong>. This is called a reflexive transport address.</p></blockquote><p>在一个 Bingding 请求 数据包经过 NAT 的时候，NAT 会修改该数据包的来源地址和端口。</p><p>对于服务器来说，接收到的这份数据包的来源地址和端口其实是<strong>离服务器最近的 NAT的公网 IP 地址和端口</strong> 。</p><p>这叫做 reflexive transport address。</p><p>??这个请求数据包的source地址叫做 reflexive transport address？??</p><blockquote><p>The STUN server copies that source transport address into an XOR-MAPPED-ADDRESS attribute in the STUN Binding response and sends the Binding response back to the STUN client. As this packet passes back through a NAT, the NAT will modify the <strong>destination</strong> transport address in the IP header, but the transport address in the XOR-MAPPED-ADDRESS attribute within the body of the STUN response will remain untouched.</p></blockquote><p>接着，STUN 服务器会产生一个 Binding 响应，然后复制收到数据包的 来源地址和端口 到 Binding 响应 里的一个叫做 XOR-MAPPED-ADDRESS 的属性中，然后将 Binding 响应 发回 STUN 客户端。</p><p>这个响应数据包也会经过 NAT，NAT 会修改该数据包的<strong>目标</strong>地址和端口。</p><p>注意，NAT 只会修改 IP 报头的地址和端口（来源或目标），不会修改 XOR-MAPPED-ADDRESS 中的内容。也就是说，NAT 只修改头部，不修改 Payload。</p><blockquote><p>In this way, the client can learn its reflexive transport address allocated by the outermost NAT with respect to the STUN server.</p></blockquote><p>通过这种方式，客户端可以了解到自己 最外部 NAT 给自己分配的的 reflexive transport address。</p><p>这里说的最外部，指的是相对于 STUN server 的最外部。套娃你懂吧，STUN server 有可能在一个非常大的子网里，这个时候客户端了解到的只是离 STUN 最近的那个 NAT 反射回的地址。</p><hr><blockquote><p>In some usages, STUN must be multiplexed with other protocols (e.g., [MMUSIC-ICE], [SIP-OUTBOUND]). In these usages, there must be a way to inspect a packet and determine if it is a STUN packet or not.</p></blockquote><p>在某些情况下， STUN 必须与其他协议复用（比如 MMUSIC-ICE, SIP-OUTBOUND）。在这些情况下，必须有一种方式来检测数据包是否为 STUN 协议类型。</p><blockquote><p>STUN provides three fields in the STUN header with fixed values that can be used for this purpose. If this is not sufficient, then STUN packets can also contain a FINGERPRINT value, which can further be used to distinguish the packets.</p></blockquote><p>STUN 在头部提供了三个字段用于其特殊情况下检测协议类型的目的。如果这三个字段仍然不够完成检测工作，那么 STUN 数据包中还可以通过包含 FINGERPRINT 值 来进一步区分数据包的协议类型。</p><hr><blockquote><p>STUN defines a set of optional procedures that a usage can decide to use, called mechanisms. These mechanisms include DNS discovery, a redirection technique to an alternate server, a fingerprint attribute for demultiplexing, and two authentication and message-integrity exchanges. The authentication mechanisms revolve around the use of a username, password, and message-integrity value. Two authentication mechanisms, the long-term credential mechanism and the short-term credential mechanism, are defined in this specification.</p></blockquote><p>STUN 定义了一系列的可选操作，称为机制。这些机制包含了：</p><ul><li><p>DNS发现机制</p></li><li><p>备选服务器的重定向机制</p></li><li><p>解多路复用[^2]的 fingerprint 属性机制</p></li><li><p>双授权机制</p></li><li><p>信息完整性交换机制</p></li></ul><p>其中，双授权机制，在本手册中定义为长期凭据机制和短期凭据机制。</p><blockquote><p>Each usage specifies the mechanisms allowed with that usage.</p></blockquote><p>不同的使用场景决定了这些机制的具体用法。换句话讲，不同的使用场景被允许使用的机制是不同的。</p><hr><blockquote><p>In the long-term credential mechanism, the client and server share a pre-provisioned username and password and perform a digest challenge / response exchange inspired by (but differing in details) to the one defined for HTTP [RFC2617].</p></blockquote><p>在长期凭据机制里，客户端和服务器共享一个预先分配好的用户名和密码，然后执行 digest challenge / response exchange。</p><p>这个长期凭据机制受到 RFC 2617 的启发，但是具体细节上与 RFC 2617 不同。</p><blockquote><p>In the short-term credential mechanism, the client and the server exchange a username and password through some out-of-band method prior to the STUN exchange. For example, in the ICE usage [MMUSIC-ICE] the two endpoints use out-of-band signaling to exchange a username and password. These are used to integrity protect and authenticate the request and response. There is no challenge or nonce used.</p></blockquote><p>在短期凭据机制里，客户端和服务器在 STUN 交换 之前，通过一些 out-of-band 的方式[^3]来交换用户名和密码。举个例子，在 ICE中，两个端点使用 out-of-band 信令 来交换用户名和密码。它们被用来保证消息的完整性和对请求和响应进行授权。没有使用 challenge 或 nonce[^4]。</p><h2 id=4-术语-terminology-4-术语-terminology4-术语-terminology><a href=#4-%E6%9C%AF%E8%AF%AD-Terminology title="4. 术语 Terminology"></a>4. 术语 Terminology
<span><a href=#4-%e6%9c%af%e8%af%ad-terminology-4-%e6%9c%af%e8%af%ad-terminology4-%e6%9c%af%e8%af%ad-terminology><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><blockquote><p>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in BCP 14, RFC 2119 [RFC2119] and indicate requirement levels for compliant STUN implementations.</p></blockquote><p>在这份文档中，“**<em>必须</em><strong>”，“</strong><em>必须不</em><strong>”，“</strong><em>必需要</em><strong>”，“</strong><em>应当</em><strong>”，“</strong><em>不应当</em><strong>”，“</strong><em>最好</em><strong>”，“</strong><em>最好不</em><strong>”，“</strong><em>建议</em><strong>”，“</strong><em>或许</em><strong>”，“</strong><em>可选</em>**”，将按照 BCP 14，RFC 2119 来解释说明 STUN 所需的的实现级别。</p><p>因为中英文单词差异，所以在本翻译中，涉及到的上述词汇都会用**<em>粗体倾斜下划线</em>**来表示。</p><h2 id=5-定义-definitions-5-定义-definitions5-定义-definitions><a href=#5-%E5%AE%9A%E4%B9%89-Definitions title="5. 定义 Definitions"></a>5. 定义 Definitions
<span><a href=#5-%e5%ae%9a%e4%b9%89-definitions-5-%e5%ae%9a%e4%b9%89-definitions5-%e5%ae%9a%e4%b9%89-definitions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><blockquote><p>STUN Agent: A STUN agent is an entity that implements the STUN protocol. The entity can be either a STUN client or a STUN server.</p></blockquote><p><strong>STUN 代理</strong>：一个实现了 STUN 协议的实体被称为 STUN 代理。（既可以为客户端又可以为服务器）</p><blockquote><p>STUN Client: A STUN client is an entity that sends STUN requests and receives STUN responses. A STUN client can also send indications. In this specification, the terms STUN client and client are synonymous.</p></blockquote><p><strong>STUN 客户端</strong>：一个可以发送 STUN 请求，且，接受 STUN 响应的实体，被称为 STUN 客户端。STUN 客户端也可以发送指示[^5]。您可以理解 STUN 客户端和客户端是同义词。</p><blockquote><p>STUN Server: A STUN server is an entity that receives STUN requests and sends STUN responses. A STUN server can also send indications. In this specification, the terms STUN server and server are synonymous.</p></blockquote><p><strong>STUN 服务器</strong>：一个可以接收 STUN 请求，且，发送 STUN 响应的实体，被称为 STUN 服务器。STUN 服务器也可以发送指示[^5]。您可以理解 STUN 服务器和服务器是同义词。</p><blockquote><p>Transport Address: The combination of an IP address and port number (such as a UDP or TCP port number).</p></blockquote><p><strong>传输地址</strong>：IP地址和端口的组合被称为传输地址。</p><blockquote><p>Reflexive Transport Address: A transport address learned by a client that identifies that client as seen by another host on an IP network, typically a STUN server. When there is an intervening NAT between the client and the other host, the reflexive transport address represents the mapped address allocated to the client on the public side of the NAT. Reflexive transport addresses are learned from the mapped address attribute (MAPPED-ADDRESS or XOR-MAPPED-ADDRESS) in STUN responses.</p></blockquote><p><strong>反射性传输地址</strong>：一个客户端从“其他主机”那里了解到的自己的传输地址。一般这个“其他主机”指的是 STUN 服务器。当 NAT 干预在客户端与“其他主机”之间时，反射性传输地址代表了这个客户端在 NAT 的公共区域那一侧被分配到的传输地址。这个反射性传输地址被放在 STUN 响应的 MAPPED-ADDRESS 或 XOR-MAPPED-ADDRESS 里。</p><p>讲人话就是，客户端拿到的公网IP地址和端口号的组合就叫反射性传输地址。（不严谨，要想严谨还是得看上面的定义）</p><blockquote><p>Mapped Address: Same meaning as reflexive address. This term is retained only for historic reasons and due to the naming of the MAPPED-ADDRESS and XOR-MAPPED-ADDRESS attributes.</p></blockquote><p><strong>映射地址</strong>：跟反射性传输地址一样。这是个因为历史原因而保留下来的词。</p><blockquote><p>Long-Term Credential: A username and associated password that represent a shared secret between client and server. Long-term credentials are generally granted to the client when a subscriber enrolls in a service and persist until the subscriber leaves the service or explicitly changes the credential.</p></blockquote><p><strong>长期凭据</strong>：客户端和服务器共享的用户名密码。长期凭据通常在订阅者订阅一个服务时授予给客户端，并且一直持续到订阅者退出服务或显式更改凭据。</p><blockquote><p>Long-Term Password: The password from a long-term credential.</p></blockquote><p><strong>长期密码</strong>：长期凭据所使用的密码。</p><blockquote><p>Short-Term Credential: A <strong>temporary</strong> username and associated password that represent a shared secret between client and server. Short-term credentials are obtained through some kind of protocol mechanism between the client and server, preceding the STUN exchange. A short-term credential has an explicit temporal scope, which may be based on a specific amount of time (such as 5 minutes) or on an event (such as termination of a SIP dialog).</p><p>The specific scope of a short-term credential is defined by the application usage.</p></blockquote><p><strong>短期凭据</strong>：客户端和服务器共享的<strong>临时的</strong>用户名密码。短期凭据一般是在 STUN 交换之前，通过某种协议机制获得的。短期凭据有一个显式的时间范围，可能基于时间量（比如 5 分钟），或，基于事件（比如 SIP 对话的终止）。</p><p>具体的时间范围，由具体的应用程序使用场景决定。</p><blockquote><p>Short-Term Password: The password component of a short-term credential.</p></blockquote><p><strong>短期密码</strong>：短期凭据所使用的密码。</p><blockquote><p>STUN Indication: A STUN message that does not receive a response.</p></blockquote><p><strong>STUN 指示</strong>：一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p><blockquote><p>Attribute: The STUN term for a Type-Length-Value (TLV) object that can be added to a STUN message. Attributes are divided into two types: comprehension-required and comprehension-optional. STUN agents can safely ignore comprehension-optional attributes they don’t understand, but cannot successfully process a message if it contains comprehension-required attributes that are not understood.</p></blockquote><p><strong>属性</strong>：一个 TLV 对象可以被附加在 STUN 消息里。一共有两种类型的属性：必须要理解的和可选理解的。STUN 代理 可以安全的忽略那些它们无法理解的、可选理解的属性，但是无法成功处理它们无法理解的、必须要理解的属性。</p><blockquote><p>RTO: Retransmission TimeOut, which defines the initial period of time between transmission of a request and the first retransmit of that request.</p></blockquote><p><strong>RTO</strong>：重传超时。也就是从请求传输到第一次重新传输之间的时间。</p><h2 id=6-stun-消息结构-stun-message-structure-6-stun-消息结构-stun-message-structure6-stun-消息结构-stun-message-structure><a href=#6-STUN-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84-STUN-Message-Structure title="6. STUN 消息结构 STUN Message Structure"></a>6. STUN 消息结构 STUN Message Structure
<span><a href=#6-stun-%e6%b6%88%e6%81%af%e7%bb%93%e6%9e%84-stun-message-structure-6-stun-%e6%b6%88%e6%81%af%e7%bb%93%e6%9e%84-stun-message-structure6-stun-%e6%b6%88%e6%81%af%e7%bb%93%e6%9e%84-stun-message-structure><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><blockquote><p>STUN messages are encoded in binary using network-oriented format (most significant byte or octet first, also commonly known as big-endian). The transmission order is described in detail in Appendix B of RFC 791 [RFC0791]. Unless otherwise noted, numeric constants are in decimal (base 10).</p></blockquote><p>STUN 消息使用 MSB 的二进制格式编码（big-endian）。传输顺序在 RFC 791 的 Appendix B 中有详细描述。除了特别注明之外，数字常量都以 10 进制表示。</p><blockquote><p>All STUN messages MUST start with a 20-byte header followed by zero or more <strong>Attributes</strong>. The STUN header contains a STUN message type, magic cookie, transaction ID, and message length.</p></blockquote><p>所有的 STUN 消息 <strong><em>必须</em></strong> 以 20-byte 长度的头部开始，紧跟着 0 个 或 多个<strong>属性</strong>。STUN 头部包含了 STUN 消息类型、magic cookie、事务ID、消息长度。</p><pre tabindex=0><code class=language-none data-lang=none> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type    |         Message Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  Figure 2: Format of STUN Message Header
</code></pre><blockquote><p>The most significant 2 bits of every STUN message MUST be zeroes. This can be used to differentiate STUN packets from other protocols when STUN is multiplexed with other protocols on the same port.</p></blockquote><p>每条 STUN 消息 的最高 2 bit <strong><em>必须</em></strong> 为零。这可以在 STUN 与其他协议在同一端口复用时，区分 STUN 数据包。</p><blockquote><p>The message type defines the message class (request, success response, failure response, or indication) and the message method (the primary function) of the STUN message. Although there are four message classes, there are only two types of transactions in STUN: request/response transactions (which consist of a request message and a response message) and indication transactions (which consist of a single <strong>indication</strong> message). Response classes are split into error and success responses to aid in quickly processing the STUN message.</p></blockquote><p>STUN 消息类型定义了消息所属的类（请求，成功的响应，失败的响应，指示），和，一条 STUN 消息的方法（主要功能）[^6]</p><p>尽管有四种消息所属的类，但在 STUN 中只有两种事务类型：请求/响应型事务（包含请求消息和响应消息），和，指示型事务（包含单独的一条<strong>STUN 指示</strong>[^7]消息）。响应类被划分为失败的响应和成功的响应，目的是帮助快速处理 STUN 消息。</p><p>更直观一点来讲：</p><ul><li>Transaction Type：请求/响应型事务<ul><li>Message Type：请求</li><li>Message Type：成功的响应</li><li>Message Type：失败的响应</li></ul></li><li>Transaction Type：指示型事务<ul><li>Message Type：指示</li></ul></li></ul><blockquote><p>The message type field is decomposed further into the following structure:</p></blockquote><p><strong>STUN Message Type</strong> 字段被分解成以下结构：</p><pre tabindex=0><code class=language-none data-lang=none> 0                 1
 2  3  4 5 6 7 8 9 0 1 2 3 4 5 
+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
|M |M |M|M|M|C|M|M|M|C|M|M|M|M|
|11|10|9|8|7|1|6|5|4|0|3|2|1|0|
+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
Figure 3: Format of STUN Message Type Field
</code></pre><blockquote><p>Here the bits in the message type field are shown as most significant (M11) through least significant (M0). M11 through M0 represent a 12-bit encoding of the method. C1 and C0 represent a 2-bit encoding of the class. A class of 0b00 is a request, a class of 0b01 is an indication, a class of 0b10 is a success response, and a class of 0b11 is an error response. This specification defines a single method, Binding. <strong>The method and class are orthogonal, so that for each method, a request, success response, error response, and indication are possible for that method.</strong> Extensions defining new methods MUST indicate which classes are permitted for that method.</p></blockquote><p>Message Type 字段从最高有效位（M11）开始到最低有效位（M0）结束。M11 到 M0 一共是 12-bit，这12个bit编码了方法。 C1 和 C- 表示类，由2个bit组成。0b00 表示一个请求，0b01 表示一个指示，0b10 表示一个成功的响应，0b11 表示一个失败的响应。</p><p>当前文档里定义了一个单独的方法，Bingding。方法和类是??正交??的关系，<strong>因此对于每个方法，都要有请求、指示、成功的响应、失败的响应。</strong></p><p>定义新的扩展方法时 <strong><em>必须</em></strong> 指明允许哪些类</p><blockquote><p>For example, a Binding request has class=0b00 (request) and method=0b000000000001 (Binding) and is encoded into the first 16 bits as 0x0001. A Binding response has class=0b10 (success response) and method=0b000000000001, and is encoded into the first 16 bits as 0x0101.</p></blockquote><p>例如，一个 Binding 方法的请求的类的编码为 0b00，方法号为 0b000000000001。前16个bit的十六进制编码为 0x0001。Binding 方法的响应的类的编码为 0b10，方法号同样为 0b000000000001，前16个bit的十六进制编码为 0x0101。</p><p>译者补充：注意，您可能会好奇，类的编码长度为2bit，方法编码长度为12bit，加起来一共14bit，为什么这里说前16bit呢？原因是，这里说的前16个bit，指的是 STUN 消息（或着说 STUN 数据包）的前16bit，对于一个 STUN 消息，最高位的 2bit 是被保留的，还记得吗？</p><blockquote><p>Note: This unfortunate encoding is due to assignment of values in [RFC3489] that did not consider encoding Indications, Success, and Errors using bit fields.</p></blockquote><p>请注意：</p><p>The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order. In RFC 3489 [RFC3489], this field was part of the transaction ID; placing the magic cookie in this location allows a server to detect if the client will understand certain attributes that were added in this revised specification. In addition, it aids in distinguishing STUN packets from packets of other protocols when STUN is multiplexed with those other protocols on the same port.</p><p>[^1]: 还记得吗，事务ID是一个随机选择的 96位 的数字<br>[^2]: 解多路复用就是与多路复用的作用相反的一个过程<br>[^3]: In <a href=https://en.wikipedia.org/wiki/Computer_networking>computer networking</a>, <strong>out-of-band data</strong> is the data transferred through a stream that is independent from the main <em>in-band</em> data stream.<br>[^4]: 在資訊安全中，Nonce是一個在加密通訊只能使用一次的數字。在認證協定中，它往往是一個隨機或偽隨機數，以避免重送攻擊。<br>[^5]: indicatino 在 indication transaction 中被发送。 指示 在 指示型事务 中被发送<br>[^6]: The method indicates which of the various requests or indications this is. 方法表示这是哪种请求，或，这是哪种指示。<br>[^7]: 一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p><h1 id=2023年8月23日注>2023年8月23日注：
<span><a href=#2023%e5%b9%b48%e6%9c%8823%e6%97%a5%e6%b3%a8><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h1><p>之前写了好多格式，现在不支持，哎
等哪天有空了把源代码找出来。。。</p></div><div class="post-info noselect"><div class="post-date dt-published"><a class=u-url href=/posts/rfc5389-stun/><time datetime=2020-06-27>June 27, 2020</time></a></div><a class="post-hidden-url u-url" href=https://www.junyi.dev/posts/rfc5389-stun/>https://www.junyi.dev/posts/rfc5389-stun/</a>
<a href=https://www.junyi.dev/ class="p-name p-author post-hidden-author h-card" rel=me>Junyi Hou</a><div class=post-taxonomies><ul class=post-tags><li><a href>#技术文章</a></li><li><a href=https://www.junyi.dev/tags/stun/>#STUN</a></li></ul></div></div></article><h3 class=read-next-title>Read next</h3><ul class=read-next-posts><li><a href=/posts/p2p/>P2P 技术</a></li></ul><script src=https://giscus.app/client.js data-repo=Junyi-99/Junyi-99.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDI4ODI3NzY=" data-category=Announcements data-category-id=DIC_kwDOFG_52M4CZZZF data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></main><footer class="common-footer noselect"><div class=common-footer-bottom><div class=copyright><p>© Junyi Hou, 2024<br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div><button class=theme-switcher>
Dark theme
</button>
<script>const STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeButtonText()};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),switchButton&&(changeButtonText(),switchButton.addEventListener("click",switchTheme,!1)),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function changeButtonText(){switchButton&&(switchButton.textContent=currentTheme=="dark"?"Light theme":"Dark theme")}function switchTheme(){currentTheme=="dark"?(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark"),changeButtonText()}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}</script></div><p class="h-card vcard"><a href=https://www.junyi.dev/ class="p-name u-url url fn" rel=me>Junyi Hou</a>
/
<a class="p-email u-email email" rel=me href=mailto:hhh@u.nus.edu>hhh@u.nus.edu</a></p></footer></div></body></html>